// vsCollisionDetection.h: 标准系统包含文件的包含文件
// 或项目特定的包含文件。

#pragma once

#include <iostream>
#include <fstream>
#include <cmath>
#include <Eigen/Dense>
#include <Eigen/Core>
#include <Eigen/Geometry>
#include "Chebyshef_40hz_Order3.h"
#define PI 3.1415926535897931
#define toRad 0.01745329252
using namespace Eigen;





class RobotDynamics {
public:
	RobotDynamics() {//初始化
		//质量
		m[0] = 8.30269;
		m[1] = 3.87623;
		m[2] = 5.31663;
		m[3] = 2.58124;
		m[4] = 2.66205;
		m[5] = 0.60427;

		//重力
		g << 0, 0, 9.81, 0;
		//重力矩
		G.resize(6, 1);
		G << 0, 0, 0, 0, 0, 0;
		//重心位置DH坐标系下
		r[0] << 0.00002, -0.051, -0.02043, 1;
		r[1] << -0.26092, 0.00001, -0.11248, 1;
		r[2] << 0.00008, -0.0181, 0.04121, 1;
		r[3] << 0.00003, -0.21887, 0.03714, 1;
		r[4] << -0.0002, -0.01507, 0.03659, 1;
		r[5] << -0.00003, -0.00106, -0.03404, 1;
		//重心位置MDH坐标系下
		r_MDH[0] << 0.00002, 0.02043, -0.051, 1;
		r_MDH[1] << 0.1941, 0.00001, -0.11248, 1;
		r_MDH[2] << 0.00008, -0.04121, -0.0181, 1;
		r_MDH[3] << 0.00003, -0.03714, -0.21887, 1;
		r_MDH[4] << 0.0002, -0.03659, 0.01507, 1;
		r_MDH[5] << -0.00003, -0.00106, -0.03404, 1;


		DH_Table.resize(6, 4);
		//DH参数表      offst	d		a		alpha
		DH_Table <<		0,		0.22,	0,		PI / 2,
						PI / 2,	0,		0.455,	0,
						0,		0,		0,		PI / 2,
						0,		0.495,	0,		PI / 2,
						0,		0,		0,		-PI / 2,
						0,		0.1565, 0,		0;
		MDH_Table.resize(6, 4);
		//DH参数表      offst	d		a		alpha
		MDH_Table <<	0,		0.22,	0,		0,
						PI / 2, 0,		0,		PI/2,
						0,		0,		0.455,	0,
						0,		0.495,	0,		PI / 2,
						PI,		0,		0,		PI / 2,
						PI,		0.1565, 0,		PI/2;

		//重心处的惯性张量,坐标系对转轴
		I[0] << 0.286765585945381,		2.33180108660000e-05,	-3.01797822000000e-05,
				2.33180108660000e-05,	0.276785769441076,		-0.0374635402223000,
				-3.01797822000000e-05,	-0.0374635402223000,	0.0254096500264570;

		I[1] << 0.329732556410064,		1.24808071840000e-05,	-3.39613350400000e-06,
				1.24808071840000e-05,	0.0551723550206150,		0.0870109096556320,
				-3.39613350400000e-06,	0.0870109096556320,		0.281093193834695;

		I[2] << 0.0322417088162830,		1.86192957840000e-05,	-2.61049976000000e-06,
				1.86192957840000e-05,	0.0123899195307320,		8.90741163699993e-05,
				-2.61049976000000e-06,	8.90741163699993e-05,	0.0266130666884150;

		I[3] << 0.249935684074060,		-3.62242239200000e-06,	-7.92051403600000e-06,
				-3.62242239200000e-06,	0.242255116698472,		0.0385644843765680,
				-7.92051403600000e-06,	0.0385644843765680,		0.0110249084018200;

		I[4] << 0.0121254081926500,		5.04285819000000e-06,	2.60580187000000e-06,
				5.04285819000000e-06,	0.00427702671386500,	2.43869688349998e-05,
				2.60580187000000e-06,	2.43869688349998e-05,	0.00983999463842500;

		I[5] << 0.00960026951610400,	2.57684214000000e-07,	1.87438712600000e-06,
				2.57684214000000e-07,	0.00954531577217500,	7.14197984520000e-05,
				1.87438712600000e-06,	7.14197984520000e-05,	0.000585850701615000;

		//重心处的惯性张量,坐标系为杆件坐标系MDH
		I_C[0] << 0.0461670394200000, - 2.67104900000000e-05,	2.11669000000000e-06,
			- 2.67104900000000e-05,	0.0396526370300000, - 0.00879709154000000,
			2.11669000000000e-06, - 0.00879709154000000,	0.0219442292700000;
		I_C[1] << 0.00613126018000000, - 4.95782000000000e-06, - 0.00239234981000000,
			- 4.95782000000000e-06,	0.134685326690000,	9.63850000000000e-07,
			- 0.00239234981000000,	9.63850000000000e-07,	0.135087058180000;
		I_C[2] << 0.0214708858000000, - 1.09143000000000e-06,	1.03089800000000e-05,
			- 1.09143000000000e-06,	0.0106481043500000,	0.00405475375000000,
			1.03089800000000e-05,	0.00405475375000000,	0.0175839908000000;
		I_C[3] << 0.0495613626300000,	6.49844000000000e-06, - 1.34622200000000e-05,
			6.49844000000000e-06,	0.0454413027300000,	0.0120926596400000,
			- 1.34622200000000e-05,	0.0120926596400000,	0.00746439628000000;
		I_C[4] << 0.00795681625000000, - 3.09477000000000e-06,	1.80346000000000e-06,
			- 3.09477000000000e-06	,0.00367246105000000, - 0.00149227142000000,
			1.80346000000000e-06, - 0.00149227142000000,	0.00627596623000000;
		I_C[5] << 0.000537684750000000,	2.76900000000000e-07,	3.45580000000000e-07,
			2.76900000000000e-07	,0.000483409420000000,	7.01904000000000e-06,
			3.45580000000000e-07,	7.01904000000000e-06,	0.000585171200000000;

		//用于求导的矩阵
		Q.resize(4, 4);
		Q <<	0, -1, 0, 0,
				1, 0, 0, 0,
				0, 0, 0, 0,
				0, 0, 0, 0;
		
		//激励轨迹系数
		coefficient_a.resize(6, 5);//行数为关节数，列数为激励轨迹系数数

		coefficient_a << 0.0263781256018620,	0.385968062866954,	0.00151963921354785, - 2.23259820096156, - 0.236581589329679,
			0.00227152284712782,	0.879744020908400, - 0.000400999188778290, - 0.00321382333358718, - 1.03366317041378,
			- 0.00301576197900402, - 0.0583730797653016, - 0.703617264049306, - 0.849316488206874,	0.0532242362778394,
			- 0.00145922259785406,	1.35762968662826,	0.00899563041500397,	0.431865441201500,	0.703475455599271,
			- 0.0363024313874441,	0.835473553811358,	0.626775106266711, - 0.0884151676496790, - 0.185546696729024,
			- 1.42142296840381, - 0.248715466638489, - 0.658690216725031, - 0.0974684674468277,	0.348436302780426;
		coefficient_b.resize(6, 5);
		coefficient_b << 0.0428367098750668, - 0.183698862830228,	0.000151555251077164,	0.367742408502640, - 0.228849190528437,
			0.000734169528191261, - 0.00598222494520594,	0.000667664535593395,	0.00641135318715942, - 0.00501691206921173,
			0.00747773418281391,	0.0339804077680129, - 0.367653926107676,	0.581809033831180, - 0.259253541479081,
			- 0.00456528309340335,	0.0281016386980187,	0.00811028481267068, - 0.0763901291357877,	0.0456079981714313,
			0.0907290430823194, - 0.491073454515073,	0.539114286512319,	0.0260060928572180, - 0.165683798060774,
			- 0.0135139866549799,	0.0488862049371129,	0.0214795498109867, - 0.135944737710421,	0.0790370039846708;
				
	}

	// 成员函数声明
	MatrixXd getMassMatrix(const VectorXd& q);//获取质量矩阵
	VectorXd getTorque(const VectorXd& q, const VectorXd& q_dot, const VectorXd& q_dot_dot, const MatrixXd& M_now);//获取关节力矩
	VectorXd getGravity();	//获取重力矩
	void getTransMatrix(const VectorXd& q,const int table_type=0);//获取齐次变换矩阵
	void coutTransMatrix();//输出齐次变换矩阵
	VectorXd getTorque_Newton_Euler(const VectorXd& q, const VectorXd& q_dot, const VectorXd& q_dot_dot);//获取关节力矩牛顿欧拉法dh
	VectorXd getTorque_Newton_Euler_MDH(const VectorXd& q, const VectorXd& q_dot, const VectorXd& q_dot_dot);//获取关节力矩牛顿欧拉法MDH
	MatrixXd getYtilde(const VectorXd& q, const VectorXd& q_dot, const VectorXd& q_dot_dot);//获取Ytilde
	void identifyDynamicsParameters(const MatrixXd&Ytilde_,const VectorXd& torque_);//辨识动力学参数, const VectorXd& torque
	MatrixXd getFourierTrajectory(const double& t);//获取傅里叶轨迹
private:
	/*变量声明*/
	//质量
	double m[6];
	//重力
	Vector4d g;
	//重心位置
	Vector4d r[6];
	//重心位置MDH坐标系下
	Vector4d r_MDH[6];
	//DH参数表
	MatrixXd DH_Table;
	MatrixXd MDH_Table;
	//惯性张量,重心位置
	Matrix3d I[6];
	//杆件坐标系处的惯性张量，以固定在杆件上的坐标系为基准
	Matrix3d I_[6];
	//重心处的惯性张量,坐标系为杆件坐标系
	Matrix3d I_C[6];
	//重力矩
	VectorXd G;
	//用于求导的矩阵，属于机器人的特性dTdq=Q*T
	MatrixXd Q;
	//齐次变换矩阵
	Matrix4d T01;
	Matrix4d T12;
	Matrix4d T23;
	Matrix4d T34;
	Matrix4d T45;
	Matrix4d T56;
	Matrix4d T02;
	Matrix4d T03;
	Matrix4d T04;
	Matrix4d T05;
	Matrix4d T06;
	//激励轨迹系数
	MatrixXd coefficient_a;
	MatrixXd coefficient_b;
	/*函数声明*/
	Matrix4d inverseHomogeneousTransform(const Matrix4d& transform);
	MatrixXd get_T_Derivative_of_time();//获取齐次变换矩阵对于时间的微分
	MatrixXd get_T_Derivative_of_qi(int T0i, int qi);//获取齐次变换矩阵对于qi的微分
	Matrix4d DH2Trans(const double theta, const double d, const double a, const double alpha, const int table_type = 0);//DH参数转换为齐次变换矩阵
	MatrixXd Operator_K(const Vector3d input);//算子K
	Matrix3d Operator_S(const Vector3d input);//算子S
};